
from os import path 
from itertools import product
from collections import OrderedDict


configfile: "config.yaml"

###################################
# Scripts
PY_SCRIPT_DIR = "scripts/python/"
JL_SCRIPT_DIR = "scripts/julia/"
R_SCRIPT_DIR = "scripts/R/"


####################################
# Raw data
RAW_DATA_DIR = "data"
RAW_TCGA_DIR = path.join(RAW_DATA_DIR, "tcga")
RAW_REACTOME_DIR = path.join(RAW_DATA_DIR, "reactome")
RAW_MSIGDB_DIR = path.join(RAW_DATA_DIR, "msigdb")
RAW_PARADIGM_DIR = path.join(RAW_DATA_DIR, "paradigm")

OUT_DIR = config["output_dir"]


####################################
# Preprocessed data
PREP_DATA_DIR = path.join(OUT_DIR, "prepped_data")
PREP_TCGA_DIR = path.join(PREP_DATA_DIR, "tcga")
PREP_PARADIGM_DIR = path.join(PREP_DATA_DIR, "paradigm")
PREP_PWY_DIR = path.join(PREP_DATA_DIR, "pathways")

# Unpack parameters for experiments
def collect_params(param_dict):
    factors = []
    for k in sorted(list(param_dict.keys())):
        v = param_dict[k]
        if isinstance(v, list):
            factors.append(["{}={}".format(k, vi) for vi in v])
        elif isinstance(v, dict):
            names = sorted(list(v.keys()))
            value_lists = [v[i] for i in names]
            unrolled = [["{}={}".format(name,value) for value in v_list] for (name, v_list) in zip(names, value_lists)]
            factors.append(["__".join(t) for t in zip(*unrolled)])
    combs = product(*factors)
    return ["__".join(c) for c in combs]


####################################
# MatFac simulation study
SIM_DIR = path.join(OUT_DIR, "simulation_study")
SIM_DATA_DIR = path.join(SIM_DIR, "simulated_data")
SIM_PARAM_DIR = path.join(SIM_DIR, "simulated_params")
SIM_FIT_PARAM_DIR = path.join(SIM_DIR, "fitted_params")
SIM_FIT_TRANS_DIR = path.join(SIM_DIR, "transformed_data")
SIM_FIT_HIST_DIR = path.join(SIM_DIR, "training_histories")
SIM_SCORE_JSON_DIR = path.join(SIM_DIR, "score_jsons") 
SIM_SCORE_TSV_DIR = path.join(SIM_DIR, "tabulated_scores") 
SIM_VIS_DIR = path.join(SIM_DIR, "visuals") 
SIM_VIS_FITTED = path.join(SIM_VIS_DIR, "fitted")
SIM_VIS_TRUE = path.join(SIM_VIS_DIR, "true")

SIM_ALL_PARAMS = config["matfac_simulation_study"]
SIM_ALL_EXPERIMENTS = list(SIM_ALL_PARAMS.keys())

SIM_REPS = [["rep={}".format(n) for n in range(SIM_ALL_PARAMS[k]["n_reps"])] for k in SIM_ALL_EXPERIMENTS]
SIM_PWY_PARAMS = [collect_params(SIM_ALL_PARAMS[k]["pathways"]) for k in SIM_ALL_EXPERIMENTS]
SIM_DATA_PARAMS = [collect_params(SIM_ALL_PARAMS[k]["data_params"]) for k in SIM_ALL_EXPERIMENTS]
SIM_PARAMS = [collect_params(SIM_ALL_PARAMS[k]["sim_params"]) for k in SIM_ALL_EXPERIMENTS]
SIM_FIT_PARAMS = [collect_params(SIM_ALL_PARAMS[k]["fit_params"]) for k in SIM_ALL_EXPERIMENTS]

SIM_ALL_SIM_COMBINATIONS = [path.join(*t) for tup in zip(SIM_DATA_PARAMS, SIM_PWY_PARAMS, SIM_PARAMS, SIM_REPS) for t in product(*tup)]

SIM_EXP_FIT_COMBINATIONS = [[path.join(*t) for t in product(*tup) ] for tup in zip(SIM_DATA_PARAMS, SIM_PWY_PARAMS, SIM_PARAMS, SIM_FIT_PARAMS, SIM_REPS)]
SIM_ALL_FIT_COMBINATIONS = sum(SIM_EXP_FIT_COMBINATIONS, []) 
SIM_EXP_FIT_COMBINATIONS = dict(zip(SIM_ALL_EXPERIMENTS, SIM_EXP_FIT_COMBINATIONS)) 

#print(SIM_ALL_SIM_COMBINATIONS)

########################################
# TCGA runs
EXP_DIR = path.join(OUT_DIR, "tcga_runs")
EXP_FIT_PARAM_DIR = path.join(EXP_DIR, "fitted_params")
EXP_FIT_TRANS_DIR = path.join(EXP_DIR, "transformed_data")
EXP_FIT_HIST_DIR = path.join(EXP_DIR, "training_histories")
EXP_VIS_DIR = path.join(EXP_DIR, "visuals")

EXP_ALL_PARAMS = config["matfac_tcga_runs"]
EXP_ALL_EXPERIMENTS = list(EXP_ALL_PARAMS.keys())

EXP_REPS = [["rep={}".format(n) for n in range(EXP_ALL_PARAMS[k]["n_reps"])] for k in EXP_ALL_EXPERIMENTS]
EXP_PWY_PARAMS = [collect_params(EXP_ALL_PARAMS[k]["pathways"]) for k in EXP_ALL_EXPERIMENTS]
EXP_DATA_PARAMS = [collect_params(EXP_ALL_PARAMS[k]["data_params"]) for k in EXP_ALL_EXPERIMENTS]
EXP_FIT_PARAMS = [collect_params(EXP_ALL_PARAMS[k]["fit_params"]) for k in EXP_ALL_EXPERIMENTS]
EXP_ALL_EXP_COMBINATIONS = [path.join(*t) for tup in zip(EXP_DATA_PARAMS, EXP_PWY_PARAMS, EXP_REPS) for t in product(*tup)]

EXP_EXP_FIT_COMBINATIONS = [[path.join(*t) for t in product(*tup) ] for tup in zip(EXP_DATA_PARAMS, EXP_PWY_PARAMS, EXP_FIT_PARAMS, EXP_REPS)]
EXP_ALL_FIT_COMBINATIONS = sum(EXP_EXP_FIT_COMBINATIONS, []) 
EXP_EXP_FIT_COMBINATIONS = dict(zip(EXP_ALL_EXPERIMENTS, EXP_EXP_FIT_COMBINATIONS)) 

####################################
# MOFA
MOFA_PYTHON = config["mofa_python"]

####################################
# Supervised learning tasks
SUP_NFOLDS = config["supervised_folds"]

SUP_DIR = path.join(OUT_DIR, "supervised_tasks")
SUP_SPLIT_DIR = path.join(SUP_DIR, "data_splits")
SUP_FIT_TRANS_DIR = path.join(SUP_DIR, "fitted_transforms")
SUP_FIT_HIST_DIR = path.join(SUP_DIR, "training_histories")
SUP_TRANS_TRAIN_DIR = path.join(SUP_DIR, "transformed_training_sets")
SUP_TRANS_TEST_DIR = path.join(SUP_DIR, "transformed_test_sets")
SUP_FIT_PRED_DIR = path.join(SUP_DIR, "fitted_predictors")
SUP_SCORE_DIR = path.join(SUP_DIR, "score_jsons")
SUP_VIS_DIR = path.join(SUP_DIR, "visuals")

SUP_ALL_PARAMS = config["supervised_tasks"]
SUP_ALL_EXPERIMENTS = list(SUP_ALL_PARAMS.keys())
SUP_FOLDS = [f"fold={f}" for f in range(SUP_NFOLDS)]
SUP_DATA_PARAMS = [collect_params(SUP_ALL_PARAMS[k]["data_params"]) for k in SUP_ALL_EXPERIMENTS]
SUP_SPLIT_PARAMS = [[f"target={t}__task={tk}__groupby={g}" for (t,tk,g) in zip(SUP_ALL_PARAMS[k]["targets"], SUP_ALL_PARAMS[k]["tasks"], SUP_ALL_PARAMS[k]["groupby"])] for k in SUP_ALL_EXPERIMENTS]

SUP_ALL_SPLIT_COMBINATIONS = [path.join(*t) for tup in zip(SUP_DATA_PARAMS, SUP_SPLIT_PARAMS) for t in product(*tup, SUP_FOLDS)]

SUP_PWY_PARAMS = [collect_params(SUP_ALL_PARAMS[k]["pathway_params"]) for k in SUP_ALL_EXPERIMENTS]
SUP_METHOD_PARAMS = [[f"method={m}/{p}" for (m,v) in SUP_ALL_PARAMS[k]["method_params"].items() for p in collect_params(v)] for k in SUP_ALL_EXPERIMENTS]
SUP_TRANS_FIT_COMBINATIONS = [path.join(*t) for tup in zip(SUP_DATA_PARAMS, SUP_SPLIT_PARAMS, SUP_PWY_PARAMS, SUP_METHOD_PARAMS) for t in product(*tup, SUP_FOLDS)]

SUP_EXP_COMBINATIONS = {ex: [path.join(*t) for t in product(*tup)] for ex, tup in zip(SUP_ALL_EXPERIMENTS, zip(SUP_DATA_PARAMS, SUP_SPLIT_PARAMS, SUP_PWY_PARAMS, SUP_METHOD_PARAMS)) }

#print(SUP_TRANS_FIT_COMBINATIONS)

#################################################################
# SNAKEMAKE RULES
#################################################################

rule all:
    input:
        ##################################
        # Simulations
        ##################################
        ## Simulation scoring
        sim_score_tsvs=expand(path.join(SIM_SCORE_TSV_DIR, "{experiment}.tsv"),
                              experiment=SIM_ALL_EXPERIMENTS),
        #sim_score_jsons=expand(path.join(SIM_SCORE_JSON_DIR, "{sim_fit_comb}.json"),
        #                       sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        ## Simulation static visuals
        #sim_batch_plots=expand(path.join(SIM_VIS_FITTED, "{sim_fit_comb}/batch_scatter.png"),
        #                       sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_fit_x_plots=expand(path.join(SIM_VIS_FITTED, "{sim_fit_comb}/X.png"),
        #                       sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_fit_y_plots=expand(path.join(SIM_VIS_FITTED, "{sim_fit_comb}/Y.png"),
        #                       sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_fit_col_param_plots=expand(path.join(SIM_VIS_FITTED, "{sim_fit_comb}/col_params.png"),
        #                               sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_x_plots=expand(path.join(SIM_VIS_TRUE, "{sim_comb}/X.png"),
        #                   sim_comb=SIM_ALL_SIM_COMBINATIONS),
        #sim_y_plots=expand(path.join(SIM_VIS_TRUE, "{sim_comb}/Y.png"),
        #                   sim_comb=SIM_ALL_SIM_COMBINATIONS),
        #sim_dataset_plots=expand(path.join(SIM_VIS_TRUE, "{sim_comb}/dataset.png"),
        #                         sim_comb=SIM_ALL_SIM_COMBINATIONS),
        ## Simulation model fits
        #sim_fit_hdfs=expand(path.join(SIM_FIT_PARAM_DIR, "{sim_fit_comb}.hdf"),
        #                      sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_fit_params=expand(path.join(SIM_FIT_PARAM_DIR, "{sim_fit_comb}.bson"),
        #                      sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        ## Simulation interactive visuals
        #sim_fit_interactive_plots=expand(path.join(SIM_VIS_FITTED, "{sim_fit_comb}/model.html"),
        #                                 sim_fit_comb=SIM_ALL_FIT_COMBINATIONS),
        #sim_true_interactive_plots=expand(path.join(SIM_VIS_TRUE, "{sim_comb}/model.html"),
        #                                 sim_comb=SIM_ALL_SIM_COMBINATIONS),
        ## Simulated data & params
        #sim_hdfs=expand(path.join(SIM_PARAM_DIR, "{sim_comb}.hdf"),
        #                sim_comb=SIM_ALL_SIM_COMBINATIONS),
        #sim_params=expand(path.join(SIM_PARAM_DIR, "{sim_comb}.bson"),
        #                  sim_comb=SIM_ALL_SIM_COMBINATIONS),
        #
        #####################################
        # TCGA runs
        #####################################
        # Visuals
        #exp_fit_interactive_plots=expand(path.join(EXP_VIS_DIR, "{exp_fit_comb}/model.html"),
        #                                 exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        #exp_fit_x_plots=expand(path.join(EXP_VIS_DIR, "{exp_fit_comb}/X.png"),
        #                       exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        #exp_fit_y_plots=expand(path.join(EXP_VIS_DIR, "{exp_fit_comb}/Y.png"),
        #                       exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        #exp_fit_batch_param_plots=expand(path.join(EXP_VIS_DIR, "{exp_fit_comb}/batch_params.png"),
        #                                 exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        #exp_fit_col_param_plots=expand(path.join(EXP_VIS_DIR, "{exp_fit_comb}/col_params.png"),
        #                               exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        # Parameters
        #exp_fit_hdfs=expand(path.join(EXP_FIT_PARAM_DIR, "{exp_fit_comb}.hdf"),
        #                    exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        #exp_fit_bsons=expand(path.join(EXP_FIT_PARAM_DIR, "{exp_fit_comb}.bson"),
        #                     exp_fit_comb=EXP_ALL_FIT_COMBINATIONS),
        ####################################
        # Supervised tasks
        ####################################
        # Transform scatter plots
        #sup_scatter=expand(path.join(SUP_VIS_DIR, "embedding_scatter", "{experiment}/{fold}.png"),
        #                   experiment=["multiomic_predictions_hpv", "mrnaseq_predictions_hpv"], fold=SUP_FOLDS),
        #sup_score_plots=expand(path.join(SUP_VIS_DIR, "score_charts", "{experiment}.png"),
        #                                experiment=["multiomic_predictions_hpv", "mrnaseq_predictions_hpv", "mrnaseq_cna_predictions_hpv"]),
        # Visualized transformed matfac
        #sup_trans_test_matfac_vis=expand(path.join(SUP_VIS_DIR, "{fit_comb}__{tt}.html"),
        #                                 fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if ("basic" in c)],
        #                                 tt=["train","test"]),
        # Prediction scores
        #sup_score_jsons=expand(path.join(SUP_SCORE_DIR, "{sup_comb}__scores.json"),
        #                       sup_comb=SUP_TRANS_FIT_COMBINATIONS),
        ## Transformed test sets
        #sup_trans_test_raw=expand(path.join(SUP_TRANS_TEST_DIR, "{fit_comb}.hdf"),
        #                           fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "raw" in c]),
        #sup_trans_test_pca=expand(path.join(SUP_TRANS_TEST_DIR, "{fit_comb}.hdf"),
        #                           fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "pca" in c]),
        #sup_trans_test_mofa=expand(path.join(SUP_TRANS_TEST_DIR, "{fit_comb}.hdf"),
        #                           fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "mofa" in c]),
        #sup_trans_test_matfac=expand(path.join(SUP_TRANS_TEST_DIR, "{fit_comb}.hdf"),
        #                             fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "matfac" in c]),
        #sup_trans_test_paradigm=expand(path.join(SUP_TRANS_TEST_DIR, "{fit_comb}.hdf"),
        #                             fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "paradigm" in c]),
        ## Fitted classifiers, regressors, survival regressors
        #sup_trained_surv=expand(path.join(SUP_FIT_PRED_DIR, "{pred_comb}.rds"),
        #                       pred_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "task=surv" in c]),
        #sup_trained_reg=expand(path.join(SUP_FIT_PRED_DIR, "{pred_comb}.pkl"),
        #                       pred_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "task=reg" in c]),
        #sup_trained_cls=expand(path.join(SUP_FIT_PRED_DIR, "{pred_comb}.pkl"),
        #                       pred_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "task=cls" in c]),
        ## Fitted transforms
        #sup_fitted_gsva=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.rds"),
        #                        fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "gsva" in c]),
        #sup_fitted_plier=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.rds"),
        #                        fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "plier" in c]),
        #sup_fitted_mofa=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.rds"),
        #                      fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "mofa" in c]),
        #sup_fitted_pca=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.hdf"),
        #                      fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "pca" in c]),
        #sup_fitted_matfacs=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.bson"),
        #                          fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "matfac" in c]),
        #sup_fitted_paradigm=expand(path.join(SUP_FIT_TRANS_DIR, "{fit_comb}.hdf"),
        #                          fit_comb=[c for c in SUP_TRANS_FIT_COMBINATIONS if "paradigm" in c]),
        #sup_splits=expand(path.join(SUP_SPLIT_DIR, "{split_comb}__{sp}.hdf"),
        #                  split_comb=SUP_ALL_SPLIT_COMBINATIONS, sp=["train","test"])



#####################################################################
# Helper functions
#####################################################################

def get_cancer_types(wc, key="tcga_params"):
    kv = [kv for kv in wc[key].split("__") if "kept_ctype" in kv][0]
    ctypes_str = kv.split("=")[-1]
    ctypes = ctypes_str.split(":")
    return ctypes


#####################################################################
# Supervised tasks
#####################################################################

######### Supervised task visualizations ######################

rule sup_vis_scores:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_predictor_scores.py"),
        score_jsons=lambda wc: [path.join(SUP_SCORE_DIR, f"{comb}", f"fold={fold}__scores.json") for comb in SUP_EXP_COMBINATIONS[wc["experiment"]] for fold in range(SUP_NFOLDS)],
    output:
        out_png=path.join(SUP_VIS_DIR, "score_charts", "{experiment,[^/]+}.png")
    shell:
        "python {input.src} {output.out_png} --score_jsons {input.score_jsons} --n_folds {SUP_NFOLDS}"

rule sup_vis_scatter:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_prediction_embeddings.py"),
        train_hdfs=lambda wc: [path.join(SUP_TRANS_TRAIN_DIR, f"{comb}", "fold={fold}.hdf") for comb in SUP_EXP_COMBINATIONS[wc["experiment"]]],
        test_hdfs=lambda wc: [path.join(SUP_TRANS_TEST_DIR, f"{comb}", "fold={fold}.hdf") for comb in SUP_EXP_COMBINATIONS[wc["experiment"]]]
    output:
        out_png=path.join(SUP_VIS_DIR, "embedding_scatter", "{experiment,[^/]+}/fold={fold,[0-9]+}.png")
    shell:
        "python {input.src} {output.out_png} --train_hdfs {input.train_hdfs} --test_hdfs {input.test_hdfs}"

rule sup_vis_test_interactive:
    input:
        src=path.join(JL_SCRIPT_DIR, "vis_model.jl"),
        transformed_bson=path.join(SUP_TRANS_TEST_DIR, "{path}.bson"),
    output:
        param_html=path.join(SUP_VIS_DIR, "{path}__test.html"),
    shell:
        "julia --project=. {input.src} {input.transformed_bson} {output.param_html}"

rule sup_vis_train_interactive:
    input:
        src=path.join(JL_SCRIPT_DIR, "vis_model.jl"),
        transformed_bson=path.join(SUP_FIT_TRANS_DIR, "{path}.bson"),
    output:
        param_html=path.join(SUP_VIS_DIR, "{path}__train.html"),
    shell:
        "julia --project=. {input.src} {input.transformed_bson} {output.param_html}"



########### Predict and score on test data ###########

rule sup_score_survival_regressor:
    input:
        src=path.join(R_SCRIPT_DIR, "score_survival_regressor.R"),
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params}/target={t}__task=surv__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.rds"),
        test_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params}/target={t}__task=surv__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf")
    output:
        score_json=path.join(SUP_SCORE_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=surv__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}__scores.json"),
        other_json=path.join(SUP_SCORE_DIR, "{data_params}/target={t}__task=surv__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}__other.json")
    shell:
        "Rscript {input.src} {input.trained_model} {input.test_hdf} {output.score_json} {output.other_json}"


rule sup_score_regressor:
    input:
        src=path.join(PY_SCRIPT_DIR, "score_regressor.py"),
        train_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/target={t}__task=reg__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf"),
        test_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params}/target={t}__task=reg__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf"),
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params}/target={t}__task=reg__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.pkl"),
    output:
        score_json=path.join(SUP_SCORE_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=reg__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}__scores.json"),
        other_json=path.join(SUP_SCORE_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=reg__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}__other.json")
    shell:
        "python {input.src} {input.trained_model} {input.train_hdf} {input.test_hdf} {output.score_json} {output.other_json}"


rule sup_score_classifier:
    input:
        src=path.join(PY_SCRIPT_DIR, "score_classifier.py"),
        train_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/target={t}__task=cls__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf"),
        test_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params}/target={t}__task=cls__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf"),
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params}/target={t}__task=cls__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.pkl"),
    output:
        score_json=path.join(SUP_SCORE_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=cls__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}__scores.json"),
        other_json=path.join(SUP_SCORE_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=cls__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}__other.json")
    shell:
        "python {input.src} {input.trained_model} {input.train_hdf} {input.test_hdf} {output.score_json} {output.other_json}"


########### Transform test data ###########

rule sup_transform_raw:
    input:
        src=path.join(PY_SCRIPT_DIR, "transform_raw.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=raw/{fit_params}/fold={fold}.hdf"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=raw/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
    resources:
        mem_mb=8000,
    threads: 1 
    shell:
        "python {input.src} {input.data_hdf} {input.fitted_hdf} {output.transformed_hdf}"

rule sup_transform_gsva:
    input:
        src=path.join(R_SCRIPT_DIR, "transform_gsva.R"),
        train_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
        test_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=gsva/{fit_params}/fold={fold}.rds"),
        pwy_json=lambda wc: [path.join(PREP_PWY_DIR, kv.split("=")[1]+".json") for kv in wc["pwy_params"].split("__") if kv.startswith("mrnaseq")]
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=gsva/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]]
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "Rscript {input.src} {input.train_hdf} {input.test_hdf} {input.fitted_rds} {input.pwy_json} {output.transformed_hdf} --threads {threads}"


rule sup_transform_plier:
    input:
        src=path.join(R_SCRIPT_DIR, "transform_plier.R"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=plier/{fit_params}/fold={fold}.rds"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=plier/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "Rscript {input.src} {input.data_hdf} {input.fitted_rds} {output.transformed_hdf}"


rule sup_transform_mofa:
    input:
        src=path.join(R_SCRIPT_DIR, "transform_mofa.R"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=mofa/{fit_params}/fold={fold}.rds"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=mofa/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "Rscript {input.src} {input.data_hdf} {input.fitted_rds} {output.transformed_hdf}"


rule sup_transform_paradigm:
    input:
        src=path.join(PY_SCRIPT_DIR, "transform_paradigm.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        paradigm_hdf=path.join(PREP_PARADIGM_DIR, "paradigm.hdf"),
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=paradigm/{fit_params}/fold={fold}.hdf"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=paradigm/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
    resources:
        mem_mb=8000
    shell:
        "python {input.src} {input.data_hdf} {input.paradigm_hdf} {input.fitted_hdf} {output.transformed_hdf}"

rule sup_transform_pca:
    input:
        src=path.join(PY_SCRIPT_DIR, "transform_pca.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=pca/{fit_params}/fold={fold}.hdf"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=pca/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "python {input.src} {input.data_hdf} {input.fitted_hdf} {output.transformed_hdf}"


rule sup_transform_matfac:
    input:
        src=path.join(JL_SCRIPT_DIR, "transform_matfac.jl"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__test.hdf"),
        fitted_bson=path.join(SUP_FIT_TRANS_DIR, "{data_params}/{split_params}/{pwy_params}/method=matfac{mf_mode}/{fit_params}/fold={fold}.bson"),
    output:
        transformed_hdf=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=matfac{mf_mode,[_a-z]*}/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
        transformed_bson=path.join(SUP_TRANS_TEST_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=matfac{mf_mode,[_a-z]*}/{fit_params,[^/]+}/fold={fold,[0-9]+}.bson"),
    params:
        parsed_opts=lambda wc: wc["fit_params"].split("__"),
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "julia --project=. {input.src} {input.data_hdf} {input.fitted_bson} {output.transformed_hdf} {output.transformed_bson} {params.parsed_opts}"


########### Fit classifiers/regressors ############

rule sup_fit_survival:
    input:
        src="scripts/R/fit_survival_regressor.R",
        transformed_train=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/target={t}__task=surv__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf")
    output:
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=surv__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}.rds"),
    shell:
        "Rscript {input.src} {input.transformed_train} {output.trained_model}"

rule sup_fit_regressor:
    input:
        src="scripts/python/fit_regressor.py",
        transformed_train=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/target={t}__task=reg__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf")
    output:
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=reg__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}.pkl"),
        training_scores=path.join(SUP_FIT_PRED_DIR, "{data_params}/target={t}__task=reg__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.json")
    shell:
        "python {input.src} {input.transformed_train} {output.trained_model} {output.training_scores} --target {wildcards.t}"


rule sup_fit_classifier:
    input:
        src="scripts/python/fit_classifier.py",
        transformed_train=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/target={t}__task=cls__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.hdf")
    output:
        trained_model=path.join(SUP_FIT_PRED_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task=cls__groupby={gb,[^/]+}/{pwy_params,[^/]+}/{method_params,[^/]+}/{fit_params,[^/]+}/fold={fold,[0-9]+}.pkl"),
        training_scores=path.join(SUP_FIT_PRED_DIR, "{data_params}/target={t}__task=cls__groupby={gb}/{pwy_params}/{method_params}/{fit_params}/fold={fold}.json")
    shell:
        "python {input.src} {input.transformed_train} {output.trained_model} {output.training_scores}"


########### Fit "transforms" ############

rule sup_fit_raw:
    input:
        src=path.join(PY_SCRIPT_DIR, "fit_raw.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
    output:
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=raw/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=raw/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]]
    threads: 1 
    shell:
        "python {input.src} {input.data_hdf} {output.fitted_hdf} {output.transformed_hdf} {params.parsed_opts}"


rule sup_fit_gsva:
    input:
        src=path.join(R_SCRIPT_DIR, "fit_gsva.R"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
        pwy_json=lambda wc: [path.join(PREP_PWY_DIR, kv.split("=")[1]+".json") for kv in wc["pwy_params"].split("__") if kv.startswith("mrnaseq")]
    output:
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=gsva/{fit_params,[^/]+}/fold={fold,[0-9]+}.rds"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=gsva/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]]
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "Rscript {input.src} {input.data_hdf} {input.pwy_json} {output.fitted_rds} {output.transformed_hdf} {params.parsed_opts} --threads {threads}"


rule sup_fit_plier:
    input:
        src=path.join(R_SCRIPT_DIR, "fit_plier.R"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
        pwy_json=lambda wc: [path.join(PREP_PWY_DIR, kv.split("=")[1]+".json") for kv in wc["pwy_params"].split("__") if kv.startswith("mrnaseq")]
    output:
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=plier/{fit_params,[^/]+}/fold={fold,[0-9]+}.rds"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=plier/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]],
    shell:
        "Rscript {input.src} {input.data_hdf} {input.pwy_json} {output.fitted_rds} {output.transformed_hdf} {params.parsed_opts}"


rule sup_fit_paradigm:
    input:
        src=path.join(PY_SCRIPT_DIR, "fit_paradigm.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
        paradigm_hdf=path.join(PREP_PARADIGM_DIR, "paradigm.hdf")
    output:
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=paradigm/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=paradigm/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]],
    shell:
        "python {input.src} {input.data_hdf} {input.paradigm_hdf} {output.fitted_hdf} {output.transformed_hdf} {params.parsed_opts}"


rule sup_fit_mofa:
    input:
        src=path.join(R_SCRIPT_DIR, "fit_mofa.R"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf")
    output:
        fitted_rds=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=mofa/{fit_params,[^/]+}/fold={fold,[0-9]+}.rds"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=mofa/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]]
    shell:
        "Rscript {input.src} {input.data_hdf} {output.fitted_rds} {output.transformed_hdf} {params.parsed_opts} --mofa_python {MOFA_PYTHON}"


rule sup_fit_pca:
    input:
        src=path.join(PY_SCRIPT_DIR, "fit_pca.py"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf")
    output:
        fitted_hdf=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=pca/{fit_params,[^/]+}/fold={fold,[0-9]+}.hdf"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=pca/{fit_params}/fold={fold}.hdf")
    params:
        parsed_opts=lambda wc: [f"--{kv[0]} {kv[1]}" for kv in [kv.split("=") for kv in wc["fit_params"].split("__")]]
    shell:
        "python {input.src} {input.data_hdf} {output.fitted_hdf} {output.transformed_hdf} {params.parsed_opts}"


rule sup_fit_matfac:
    input:
        script=path.join(JL_SCRIPT_DIR, "fit_matfac.jl"),
        data_hdf=path.join(SUP_SPLIT_DIR, "{data_params}/{split_params}/fold={fold}__train.hdf"),
        pwy_jsons=lambda wc: [path.join(PREP_PWY_DIR, f"{pwys}.json") for pwys in [x.split("=")[-1] for x in wc["pwy_params"].split("__")]]
    output:
        fitted_bson=path.join(SUP_FIT_TRANS_DIR, "{data_params,[^/]+}/{split_params,[^/]+}/{pwy_params,[^/]+}/method=matfac{mf_mode,[_a-z]*}/{fit_params,[^/]+}/fold={fold,[0-9]+}.bson"),
        transformed_hdf=path.join(SUP_TRANS_TRAIN_DIR, "{data_params}/{split_params}/{pwy_params}/method=matfac{mf_mode,[_a-z]*}/{fit_params}/fold={fold}.hdf"),
        history_json=path.join(SUP_FIT_HIST_DIR, "{data_params}/{split_params}/{pwy_params}/method=matfac{mf_mode,[_a-z]*}/{fit_params}/fold={fold}.json"),
    params:
        parsed_opts=lambda wc: wc["fit_params"].split("__"),
        parsed_pwy_jsons=lambda wc: [f"{assay}_pwy_json="+ path.join(PREP_PWY_DIR, f"{pwys}.json") for assay, pwys in [x.split("=") for x in wc["pwy_params"].split("__")]]
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc, key="data_params")) 
    shell:
        "julia --project=. {input.script} {input.data_hdf} {output.fitted_bson} {output.transformed_hdf} {params.parsed_opts} history_json={output.history_json} {params.parsed_pwy_jsons}"


########### Prepare data ############

rule sup_prep_splits:
    input:
        src="scripts/python/prep_tcga_splits.py",
        data_hdf=path.join(PREP_TCGA_DIR, "{data_params}.hdf"),
        clinical_hdf=path.join(RAW_TCGA_DIR, "tcga_clinical.hdf"),
        paradigm_hdf=path.join(PREP_PARADIGM_DIR, "paradigm.hdf")
    output:
        train_sets=[path.join(SUP_SPLIT_DIR, "{data_params,[^/]+}/target={t,[^/]+}__task={tk,[^/]+}__groupby={gb,[^/]+}/"+f+"__train.hdf") for f in SUP_FOLDS],
        test_sets=[path.join(SUP_SPLIT_DIR, "{data_params}/target={t}__task={tk}__groupby={gb}/"+f+"__test.hdf") for f in SUP_FOLDS]
    params:
        prefix=lambda wc: "{}/{}/target={}__task={}__groupby={}/".format(SUP_SPLIT_DIR, wc["data_params"], wc["t"], wc["tk"], wc["gb"])
    resources:
        mem_mb=8000,
    shell:
        "python {input.src} {input.data_hdf} {input.clinical_hdf} {input.paradigm_hdf} {params.prefix} --n_folds {SUP_NFOLDS} --target {wildcards.t} --groupby {wildcards.gb} --paradigm_filter"



#################################################################
# TCGA RUNS: visuals
#################################################################

rule exp_vis_fit_interactive:
    input:
        src=path.join(JL_SCRIPT_DIR, "vis_model.jl"),
        fitted_bson=path.join(EXP_FIT_PARAM_DIR, "{path}.bson"),
    output:
        param_html=path.join(EXP_VIS_DIR, "{path}/model.html"),
    shell:
        "julia --project=. {input.src} {input.fitted_bson} {output.param_html}"

rule exp_vis_fit_X:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(EXP_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(EXP_VIS_DIR, "{path}/X.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param X"

rule exp_vis_fit_Y:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(EXP_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(EXP_VIS_DIR, "{path}/Y.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param Y"

rule exp_vis_fit_batch_param:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(EXP_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(EXP_VIS_DIR, "{path}/batch_params.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param batch_params"

rule exp_vis_fit_col_param:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(EXP_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(EXP_VIS_DIR, "{path}/col_params.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param col_params"

rule exp_vis_dataset:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_dataset.py"),
        param_hdf=path.join(PREP_TCGA_DIR, "{tcga_params}.hdf")
    output:
        param_png=path.join(EXP_VIS_DIR, "{tcga_params}/dataset.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --title \"Simulated dataset\""


#################################################################
# TCGA RUNS
#################################################################

rule exp_param_bson_to_hdf:
    input:
        src=path.join(JL_SCRIPT_DIR, "bson_to_hdf.jl"),
        fitted_bson=path.join(EXP_FIT_PARAM_DIR, "{path}.bson"),
    output:
        out_hdf=path.join(EXP_FIT_PARAM_DIR, "{path}.hdf"),
    shell:
        "julia --project=. {input.src} {input.fitted_bson} {output.out_hdf}"


rule exp_fit_matfac:
    input:
        src=path.join(JL_SCRIPT_DIR, "fit_matfac.jl"),
        data_hdf=path.join(PREP_TCGA_DIR, "{tcga_params}.hdf"),
        #pwy_json=path.join(PREP_PWY_DIR, "{pwy_params}.json")
        pwy_jsons=lambda wc: [path.join(PREP_PWY_DIR, f"{pwys}.json") for pwys in [x.split("=")[-1] for x in wc["pwy_params"].split("__")]]
    output:
        fitted_bson=path.join(EXP_FIT_PARAM_DIR, "{tcga_params,[^/]+}/{pwy_params,[^/]+}/{fit_params,[^/]+}/rep={rep,[0-9]+}.bson"),
        transformed_hdf=path.join(EXP_FIT_TRANS_DIR, "{tcga_params}/{pwy_params}/{fit_params}/rep={rep}.hdf"),
        history_json=path.join(EXP_FIT_HIST_DIR, "{tcga_params}/{pwy_params}/{fit_params}/rep={rep}.json")
    params:
        parsed_opts=lambda wc: wc["fit_params"].split("__"),
        parsed_pwy_jsons=lambda wc: [f"{assay}_pwy_json="+ path.join(PREP_PWY_DIR, f"{pwys}.json") for assay, pwys in [x.split("=") for x in wc["pwy_params"].split("__")]]
    resources:
        mem_mb=8000,
    threads: lambda wc: len(get_cancer_types(wc)) 
    shell:
        "julia --project=. {input.src} {input.data_hdf} {output.fitted_bson} {output.transformed_hdf} {params.parsed_opts} history_json={output.history_json} {params.parsed_pwy_jsons}"


#################################################################
# Sim visualizations
#################################################################

rule sim_vis_fit_interactive:
    input:
        src=path.join(JL_SCRIPT_DIR, "vis_model.jl"),
        fitted_bson=path.join(SIM_FIT_PARAM_DIR, "{path}.bson"),
    output:
        param_html=path.join(SIM_VIS_FITTED, "{path}/model.html"),
    shell:
        "julia --project=. {input.src} {input.fitted_bson} {output.param_html}"

rule sim_vis_true_interactive:
    input:
        src=path.join(JL_SCRIPT_DIR, "vis_model.jl"),
        fitted_bson=path.join(SIM_PARAM_DIR, "{path}.bson"),
    output:
        param_html=path.join(SIM_VIS_TRUE, "{path}/model.html"),
    shell:
        "julia --project=. {input.src} {input.fitted_bson} {output.param_html}"


rule sim_vis_compare_batch:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_param_comparison.py"),
        true_hdf=path.join(SIM_PARAM_DIR, "{sim_param}/rep={rep}.hdf"),
        fitted_hdf=path.join(SIM_FIT_PARAM_DIR, "{sim_param}/{fit_param}/rep={rep}.hdf")
    output:
        batch_png=path.join(SIM_VIS_FITTED, "{sim_param}/{fit_param}/rep={rep}/batch_scatter.png")
    shell:
        "python {input.src} {input.true_hdf} {input.fitted_hdf} {output.batch_png}"

rule sim_vis_fit_X:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(SIM_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_FITTED, "{path}/X.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param X"

rule sim_vis_fit_Y:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(SIM_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_FITTED, "{path}/Y.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param Y"

rule sim_vis_fit_col_param:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(SIM_FIT_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_FITTED, "{path}/col_params.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param col_params"

rule sim_vis_true_X:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(SIM_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_TRUE, "{path}/X.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param X"

rule sim_vis_true_Y:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_model_params.py"),
        param_hdf=path.join(SIM_PARAM_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_TRUE, "{path}/Y.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --param Y"

rule sim_vis_dataset:
    input:
        src=path.join(PY_SCRIPT_DIR, "vis_dataset.py"),
        param_hdf=path.join(SIM_DATA_DIR, "{path}.hdf")
    output:
        param_png=path.join(SIM_VIS_TRUE, "{path}/dataset.png")
    shell:
        "python {input.src} {input.param_hdf} {output.param_png} --title \"Simulated dataset\""



#################################################################
# Simulation runs
#################################################################

def sim_exp_to_paths(wc, prefix=SIM_SCORE_JSON_DIR, suffix=".json"):
    return [path.join(prefix, param_comb)+suffix for param_comb in SIM_EXP_FIT_COMBINATIONS[wc["experiment"]]]


rule sim_tabulate_experiment_results:
    input:
        src=path.join(PY_SCRIPT_DIR, "tabulate_jsons.py"),
        score_jsons=lambda wc: sim_exp_to_paths(wc)
    output:
        exp_tsv=path.join(SIM_SCORE_TSV_DIR, "{experiment,[_a-zA-Z0-9]+}.tsv")
    shell:
        "python {input.src} {output.exp_tsv} {input.score_jsons}"


rule sim_score_matfac:
    input:
        src=path.join(PY_SCRIPT_DIR, "score_matfac.py"),
        true_hdf=path.join(SIM_PARAM_DIR, "{sim_path}/rep={rep}.hdf"),
        fitted_hdf=path.join(SIM_FIT_PARAM_DIR, "{sim_path}/{fit_params}/rep={rep}.hdf")
    output:
        score_json=path.join(SIM_SCORE_JSON_DIR, "{sim_path}/{fit_params,[^/]+}/rep={rep,[0-9]+}.json")
    shell:
        "python {input.src} {input.true_hdf} {input.fitted_hdf} {output.score_json}"


rule fitted_param_bson_to_hdf:
    input:
        src=path.join(JL_SCRIPT_DIR, "bson_to_hdf.jl"),
        fitted_bson=path.join(SIM_FIT_PARAM_DIR, "{path}.bson"),
    output:
        out_hdf=path.join(SIM_FIT_PARAM_DIR, "{path}.hdf"),
    shell:
        "julia --project=. {input.src} {input.fitted_bson} {output.out_hdf}"


rule true_param_bson_to_hdf:
    input:
        src=path.join(JL_SCRIPT_DIR, "bson_to_hdf.jl"),
        true_bson=path.join(SIM_PARAM_DIR, "{path}.bson"),
    output:
        out_hdf=path.join(SIM_PARAM_DIR, "{path}.hdf"),
    shell:
        "julia --project=. {input.src} {input.true_bson} {output.out_hdf}"


rule sim_fit_matfac:
    input:
        src=path.join(JL_SCRIPT_DIR, "fit_matfac.jl"),
        data_hdf=path.join(SIM_DATA_DIR, "{tcga_params}/{pwy_params}/{sim_params}/rep={rep}.hdf"),
        #pwy_json=path.join(PREP_PWY_DIR, "{pwy_params}.json")
        pwy_jsons=lambda wc: [path.join(PREP_PWY_DIR, f"{pwys}.json") for pwys in [x.split("=")[-1] for x in wc["pwy_params"].split("__")]]
    output:
        fitted_bson=path.join(SIM_FIT_PARAM_DIR, "{tcga_params,[^/]+}/{pwy_params,[^/]+}/{sim_params,[^/]+}/{fit_params,[^/]+}/rep={rep,[0-9]+}.bson"),
        transformed_hdf=path.join(SIM_FIT_TRANS_DIR, "{tcga_params}/{pwy_params}/{sim_params}/{fit_params}/rep={rep}.hdf"),
        history_json=path.join(SIM_FIT_HIST_DIR, "{tcga_params}/{pwy_params}/{sim_params}/{fit_params}/rep={rep}.json")
    params:
        parsed_opts=lambda wc: wc["fit_params"].split("__"),
        parsed_pwy_jsons=lambda wc: [f"{assay}_pwy_json="+ path.join(PREP_PWY_DIR, f"{pwys}.json") for assay, pwys in [x.split("=") for x in wc["pwy_params"].split("__")]]
    resources:
        mem_mb=8000,
    threads: 1 #lambda wc: len(get_cancer_types(wc)) 
    shell:
        "julia --project=. {input.src} {input.data_hdf} {output.fitted_bson} {output.transformed_hdf} {params.parsed_opts} history_json={output.history_json} {params.parsed_pwy_jsons}"


rule simulate_data:
    input:
        src=path.join(JL_SCRIPT_DIR, "simulate_matfac.jl"),
        template_data_hdf=path.join(PREP_TCGA_DIR, "{tcga_params}.hdf"),
        #template_pwys_json=path.join(PREP_PWY_DIR, "{pwy_params}.json"),
        pwy_jsons=lambda wc: [path.join(PREP_PWY_DIR, f"{pwys}.json") for pwys in [x.split("=")[-1] for x in wc["pwy_params"].split("__")]]
    output:
        true_param_bson=path.join(SIM_PARAM_DIR, "{tcga_params}/{pwy_params}/{sim_params}/rep={rep}.bson"),
        simulated_hdf=path.join(SIM_DATA_DIR, "{tcga_params,[^/]+}/{pwy_params,[^/]+}/{sim_params,[^/]+}/rep={rep,[0-9]+}.hdf")
    params:
        parsed_opts=lambda wc: wc["sim_params"].split("__"),
        parsed_pwy_jsons=lambda wc: [f"{assay}_pwy_json="+ path.join(PREP_PWY_DIR, f"{pwys}.json") for assay, pwys in [x.split("=") for x in wc["pwy_params"].split("__")]]
    resources:
        mem_mb=4000
    shell:
        "julia --project=. {input.src} {input.template_data_hdf} {output.true_param_bson} {output.simulated_hdf} {params.parsed_opts} {params.parsed_pwy_jsons}"


#####################################################################
# Download and preprocess precomputed PARADIGM outputs
#####################################################################

rule exp_prep_paradigm:
    input:
        src="scripts/python/prep_paradigm.py",
        paradigm_txt=path.join(RAW_PARADIGM_DIR, "merge_merged_reals.txt"),
    output:
        out_hdf=path.join(PREP_PARADIGM_DIR, "paradigm.hdf")
    shell:
        "python {input.src} {input.paradigm_txt} {output.out_hdf}"

rule exp_download_paradigm:
    output:
        paradigm_tar=path.join(RAW_PARADIGM_DIR, "merge_merged_reals.tar.gz"),
        paradigm_txt=path.join(RAW_PARADIGM_DIR, "merge_merged_reals.txt")
    shell:
        "curl {PARADIGM_URL} --output {output.paradigm_tar} && tar -xvzf {output.paradigm_tar} --directory {RAW_PARADIGM_DIR}"


#####################################################################
# Preprocess MSigDB
#####################################################################

def collect_msigdb_names(wc):
    return wc["name"].split(":")


rule prep_msigdb_json:
    input:
        src=path.join(PY_SCRIPT_DIR, "prep_msigdb_json.py"),
        raw_jsons=lambda wc: [path.join(RAW_MSIGDB_DIR, n+".json") for n in wc["name"].split(":")]
    output:
        pwy_json=path.join(PREP_PWY_DIR,"{name}.json")
    shell:
        "python {input.src} {input.raw_jsons} {output.pwy_json}"


#####################################################################
# Download and preprocess Reactome
#####################################################################

rule select_topk_pwys:
    input:
        src="scripts/python/prep_select_pathways.py",
        ranked_json=path.join(RAW_REACTOME_DIR, "reactome_ranked.json"),
    output:
        pwy_json=path.join(RAW_REACTOME_DIR, "top_pwys={topk, [0-9]+}.json"),
    resources:
        mem_mb=500
    shell:
        "python {input.src} {input.ranked_json} {wildcards.topk} {output.pwy_json}"


rule rank_pwys:
    input:
        src="scripts/python/rank_pathways.py",
        feature_json=path.join(PREP_TCGA_DIR, "features__heldout_ctypes=.json"),
        all_pwy_json=path.join(RAW_REACTOME_DIR, "reactome.json")
    output:
        ranked_json=path.join(RAW_REACTOME_DIR, "reactome_ranked.json")
    resources:
        mem_mb=500
    shell:
        "python {input.src} {input.all_pwy_json} {input.feature_json} {output.ranked_json}"


rule reactome_txt_to_json:
    input:
        src="scripts/python/reactome_txt_to_json.py",
        txt=path.join(RAW_REACTOME_DIR, "reactome.hgnc.txt"),
    output:
        json=path.join(RAW_REACTOME_DIR, "reactome.json")
    shell:
        "python {input.src} {input.txt} {output.json}"


rule unzip_reactome:
    input:
        zipped=path.join(RAW_REACTOME_DIR, "reactome.hgnc.txt.gz")
    output:
        tsv=path.join(RAW_REACTOME_DIR, "reactome.hgnc.txt")
    shell:
        "gunzip {input.zipped}"


rule download_reactome:
    output:
        tarball=path.join(RAW_REACTOME_DIR, "reactome.hgnc.txt.gz")
    shell:
        "curl {REACTOME_URL} --output {output.tarball}"


#####################################################################
# Download and preprocess TCGA
#####################################################################

#rule extract_samples_features:
#    input:
#        src="scripts/python/prep_extract_samples_features.py",
#        tcga_hdf=path.join(PREP_TCGA_DIR, "{kwargs}.hdf")
#    output:
#        samples_json=path.join(PREP_TCGA_DIR, "samples__{kwargs,[_:=a-zA-Z]*}.json"),
#        features_json=path.join(PREP_TCGA_DIR, "features__{kwargs,[_:=a-zA-Z]*}.json")
#    shell:
#        "python {input.src} {input.tcga_hdf} {output.samples_json} {output.features_json}"

rule preprocess_tcga:
    input:
        src="scripts/python/preprocess_tcga.py",
        tcga_hdf=path.join(RAW_TCGA_DIR, "tcga_omic.hdf")
    output:
        prep_hdf=path.join(PREP_TCGA_DIR, "{kwargs,[_:=a-zA-Z]*}.hdf") 
    params:
        opts=lambda wc: " ".join(wc["kwargs"].split("__"))
    resources:
        mem_mb=8000
    shell:
        "python {input.src} {input.tcga_hdf} {output.prep_hdf} std_assays= {params.opts}"

rule unzip_hdf:
    input:
        zipped="data/{path}/{head}.tar.gz"
    output:
        unzipped="data/{path}/{head,[_a-zA-Z0-9]+}.hdf"
    shell:
        "tar -xvzf {input.zipped} -C data/{wildcards.path}/"

rule download_tcga_omic:
    output:
        tcga_omic=path.join(RAW_TCGA_DIR, "tcga_omic.tar.gz"),
    shell:
        "curl https://zenodo.org/record/6977490/files/tcga_omic.tar.gz?download=1 -o {output.tcga_omic}"


rule download_tcga_clinical:
    output:
        tcga_clinical=path.join(RAW_TCGA_DIR, "tcga_clinical.tar.gz")
    shell:
        "curl https://zenodo.org/record/6977490/files/tcga_clinical.tar.gz?download=1 -o {output.tcga_clinical}"



#####################################################################
# GPU status
#####################################################################
rule initialize_gpu_status:
    input:
        src=path.join("scripts", "julia", "init_gpu_status.jl")
    output:
        status_file="gpu_status.txt"
    shell:
        "julia --project=. -t 1 {input.src} > {output.status_file}"



